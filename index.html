<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Practice Player (Pitch Only)</title>

  <style>
    body{font-family:sans-serif;text-align:center;padding:20px;background:#f5f6fa;}
    .card{background:white;padding:20px;border-radius:12px;box-shadow:0 5px 20px rgba(0,0,0,0.1);max-width:640px;margin:0 auto;}
    button{padding:10px 16px;margin:6px;font-size:15px;}
    .big{font-size:18px;font-weight:bold;}
    .row{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;align-items:center;}
    .hint{font-size:12px;color:#555;line-height:1.5;text-align:left;margin:10px auto;max-width:520px;}
    input[type=range]{width:100%;max-width:520px;}
    .label{font-weight:bold;margin-top:14px;}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  </style>
</head>

<body>
  <div class="card">
    <h2>ğŸ¸ ç·´ç¿’ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆéŸ³ç¨‹ã®ã¿å¤‰æ›´ / ãƒ†ãƒ³ãƒå›ºå®šï¼‰</h2>

    <div class="row">
      <input type="file" id="fileInput" accept="audio/*" />
      <button id="loadBtn">èª­ã¿è¾¼ã¿</button>
      <button id="playBtn" disabled>å†ç”Ÿ</button>
      <button id="stopBtn" disabled>åœæ­¢</button>
    </div>

    <div class="hint">
      âœ…ã€ŒéŸ³ç¨‹ã ã‘å¤‰ãˆã¦ãƒ†ãƒ³ãƒã¯å›ºå®šã€ã§ã™ï¼ˆÂ±12åŠéŸ³ï¼‰ã€‚<br>
      âš ï¸ iPhone/Safariã¯è‡ªå‹•å†ç”Ÿåˆ¶é™ãŒã‚ã‚‹ã®ã§ã€ã¾ãšã€Œèª­ã¿è¾¼ã¿ã€â†’ã€Œå†ç”Ÿã€ã§æ“ä½œã—ã¦ãã ã•ã„ã€‚<br>
      âš ï¸ ç«¯æœ«ã«ã‚ˆã£ã¦ã¯å‡¦ç†ãŒé‡ãã€é•·ã„éŸ³æºã ã¨è² è·ãŒé«˜ã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
    </div>

    <div class="label">éŸ³ç¨‹ï¼ˆåŠéŸ³ï¼‰</div>
    <input type="range" id="pitch" min="-12" max="12" step="1" value="0" disabled />
    <p class="big"><span id="pitchValue" class="mono">0</span> st</p>

    <div class="label">å†ç”Ÿä½ç½®</div>
    <input type="range" id="pos" min="0" max="1000" step="1" value="0" disabled />
    <p class="hint">â€» ãƒ”ãƒƒãƒã‚·ãƒ•ãƒˆå‡¦ç†ã®éƒ½åˆã§ã€é€šå¸¸ã®&lt;audio&gt;ã»ã©ã‚·ãƒ¼ã‚¯ãŒæ»‘ã‚‰ã‹ã˜ã‚ƒãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</p>
  </div>

  <!-- Pitch-only time-stretch/pitch-shift library -->
  <script src="https://unpkg.com/soundtouchjs@0.1.30/dist/soundtouch.min.js"></script>

  <script>
    const fileInput = document.getElementById('fileInput');
    const loadBtn   = document.getElementById('loadBtn');
    const playBtn   = document.getElementById('playBtn');
    const stopBtn   = document.getElementById('stopBtn');

    const pitch     = document.getElementById('pitch');
    const pitchValue= document.getElementById('pitchValue');

    const pos       = document.getElementById('pos');

    let ac = null;
    let audioBuffer = null;

    let sourceNode = null;
    let processor = null;

    let isPlaying = false;
    let startTime = 0;      // AudioContext time
    let startOffset = 0;    // seconds
    let duration = 0;

    // SoundTouch pipeline
    let soundtouch = null;
    let filter = null;

    function ensureAC() {
      if (!ac) ac = new (window.AudioContext || window.webkitAudioContext)();
      return ac;
    }

    function semitoneToPitchRatio(semi) {
      return Math.pow(2, semi / 12);
    }

    function stop() {
      isPlaying = false;
      if (sourceNode) {
        try { sourceNode.stop(); } catch(e) {}
        sourceNode.disconnect();
        sourceNode = null;
      }
      if (processor) {
        processor.disconnect();
        processor.onaudioprocess = null;
        processor = null;
      }
      playBtn.textContent = 'å†ç”Ÿ';
    }

    function buildPipeline(semitones) {
      // SoundTouch instance
      soundtouch = new window.soundtouch.SoundTouch(ensureAC().sampleRate);
      // tempoå›ºå®š (1.0) / rateå›ºå®š (1.0) / pitchã®ã¿å¤‰æ›´
      soundtouch.tempo = 1.0;
      soundtouch.rate  = 1.0;
      soundtouch.pitch = semitoneToPitchRatio(semitones);

      // Create a buffer source-like provider
      const channels = audioBuffer.numberOfChannels;
      const left  = audioBuffer.getChannelData(0);
      const right = channels > 1 ? audioBuffer.getChannelData(1) : null;

      const provider = {
        position: 0,
        extract: function(target, numFrames, position) {
          // position is ignored; we manage provider.position
          let i = 0;
          const maxFrames = Math.min(numFrames, (left.length - this.position));
          for (; i < maxFrames; i++) {
            target[i * 2]     = left[this.position + i];
            target[i * 2 + 1] = right ? right[this.position + i] : left[this.position + i];
          }
          this.position += maxFrames;
          return maxFrames;
        }
      };

      filter = new window.soundtouch.SimpleFilter(provider, soundtouch);
      return provider;
    }

    function playFrom(offsetSec) {
      if (!audioBuffer) return;

      const ctx = ensureAC();
      // iOSå¯¾ç­–ï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œã«resume
      ctx.resume && ctx.resume();

      stop(); // reset

      const semis = Number(pitch.value);
      pitchValue.textContent = String(semis);

      // provider positionã‚’offsetã¸
      const provider = buildPipeline(semis);
      provider.position = Math.floor(offsetSec * audioBuffer.sampleRate);

      // ScriptProcessorNode (simple, widely supported)
      const bufferSize = 4096;
      processor = ctx.createScriptProcessor(bufferSize, 0, 2);

      processor.onaudioprocess = (e) => {
        const outL = e.outputBuffer.getChannelData(0);
        const outR = e.outputBuffer.getChannelData(1);

        const frames = outL.length;
        // interleaved buffer for SoundTouch
        const temp = new Float32Array(frames * 2);
        const extracted = filter.extract(temp, frames);

        if (extracted === 0) {
          // end
          stop();
          return;
        }

        for (let i = 0; i < extracted; i++) {
          outL[i] = temp[i * 2];
          outR[i] = temp[i * 2 + 1];
        }
        // fill rest with zeros
        for (let i = extracted; i < frames; i++) {
          outL[i] = 0;
          outR[i] = 0;
        }
      };

      processor.connect(ctx.destination);

      // dummy source to drive graph timing
      sourceNode = ctx.createBufferSource();
      sourceNode.buffer = ctx.createBuffer(1, 1, ctx.sampleRate);
      sourceNode.loop = true;
      sourceNode.connect(processor);

      sourceNode.start();

      isPlaying = true;
      startTime = ctx.currentTime;
      startOffset = offsetSec;

      playBtn.textContent = 'ä¸€æ™‚åœæ­¢';

      tickUI();
    }

    function getCurrentPositionSec() {
      if (!ac) return startOffset;
      if (!isPlaying) return startOffset;
      const elapsed = ac.currentTime - startTime;
      // tempoå›ºå®šãªã®ã§ elapsed ã‚’ãã®ã¾ã¾è¶³ã™
      return Math.min(duration, startOffset + elapsed);
    }

    function tickUI() {
      if (!audioBuffer) return;

      const p = getCurrentPositionSec();
      pos.value = Math.floor((p / duration) * 1000);

      if (isPlaying) {
        requestAnimationFrame(tickUI);
      }
    }

    async function loadSelectedFile() {
      const f = fileInput.files && fileInput.files[0];
      if (!f) {
        alert('éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã‚“ã§ãã ã•ã„');
        return;
      }

      const ctx = ensureAC();
      ctx.resume && ctx.resume();

      const arrayBuffer = await f.arrayBuffer();
      audioBuffer = await ctx.decodeAudioData(arrayBuffer);
      duration = audioBuffer.duration;

      pitch.disabled = false;
      pos.disabled = false;
      playBtn.disabled = false;
      stopBtn.disabled = false;

      startOffset = 0;
      pos.value = 0;

      alert('èª­ã¿è¾¼ã¿å®Œäº†ï¼ã€Œå†ç”Ÿã€ã§ã‚¹ã‚¿ãƒ¼ãƒˆã§ãã¾ã™ã€‚');
    }

    loadBtn.addEventListener('click', () => loadSelectedFile().catch(err => {
      console.error(err);
      alert('èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆå¯¾å¿œã—ã¦ã„ãªã„å½¢å¼ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼‰');
    }));

    playBtn.addEventListener('click', () => {
      if (!audioBuffer) return;
      if (!isPlaying) {
        playFrom(startOffset);
      } else {
        // pause
        startOffset = getCurrentPositionSec();
        stop();
      }
    });

    stopBtn.addEventListener('click', () => {
      if (!audioBuffer) return;
      startOffset = 0;
      pos.value = 0;
      stop();
    });

    pitch.addEventListener('input', () => {
      pitchValue.textContent = String(pitch.value);
      // å†ç”Ÿä¸­ãªã‚‰å³åæ˜ ï¼ˆå†æ§‹ç¯‰ï¼‰
      if (audioBuffer && isPlaying) {
        const cur = getCurrentPositionSec();
        playFrom(cur);
      }
    });

    pos.addEventListener('input', () => {
      if (!audioBuffer) return;
      const sec = (Number(pos.value) / 1000) * duration;
      startOffset = sec;
      if (isPlaying) playFrom(startOffset);
    });

    // ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´æ™‚ã¯åœæ­¢ã—ã¦ãƒªã‚»ãƒƒãƒˆ
    fileInput.addEventListener('change', () => {
      stop();
      audioBuffer = null;
      duration = 0;
      startOffset = 0;
      pitch.value = 0;
      pitchValue.textContent = '0';
      pos.value = 0;

      pitch.disabled = true;
      pos.disabled = true;
      playBtn.disabled = true;
      stopBtn.disabled = true;
      playBtn.textContent = 'å†ç”Ÿ';
    });
  </script>
</body>
</html>
