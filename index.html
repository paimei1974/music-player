<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Practice Player</title>

  <style>
    body{font-family:sans-serif;text-align:center;padding:20px;background:#f5f6fa;}
    .card{background:white;padding:20px;border-radius:12px;box-shadow:0 5px 20px rgba(0,0,0,0.1);max-width:640px;margin:0 auto;}
    button{padding:10px 16px;margin:6px;font-size:15px;}
    .big{font-size:18px;font-weight:bold;}
    .row{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;align-items:center;}
    .hint{font-size:12px;color:#555;line-height:1.4;margin:8px 0 14px;}
    input[type=range]{width:100%;}
    .time{font-variant-numeric: tabular-nums;}
    .pill{display:inline-block;padding:2px 10px;border-radius:999px;background:#eef2ff;}
    .muted{color:#666;font-size:12px;}
    .section{margin-top:18px;}
    .label{margin:8px 0 6px;font-weight:bold;}
  </style>

  <!-- Pitch-shift (tempo fixed) library -->
  <!-- If this CDN ever changes, swap to another SoundTouch.js CDN. -->
  <script src="https://cdn.jsdelivr.net/npm/soundtouchjs@0.1.30/dist/soundtouch.min.js"></script>
</head>

<body>
  <div class="card">
    <h2>ğŸ¸ ç·´ç¿’ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</h2>

    <div class="row">
      <input type="file" id="fileInput" accept="audio/*" />
      <button id="loadBtn">èª­ã¿è¾¼ã¿</button>
    </div>

    <p class="hint">
      â€» iPhoneã¯ã€Œèª­ã¿è¾¼ã¿ã€ã‚’æŠ¼ã—ã¦ã‹ã‚‰å†ç”Ÿã™ã‚‹ã¨å®‰å®šã—ã¾ã™ã€‚<br>
      â€» iPhoneã®ãƒ›ãƒ¼ãƒ ç”»é¢è¿½åŠ (PWA)ã ã¨ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãŒå‹•ã‹ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ãã®æ™‚ã¯Safariã§é–‹ã„ã¦è©¦ã—ã¦ãã ã•ã„ã€‚
    </p>

    <div class="row">
      <button id="playBtn">â–¶ å†ç”Ÿ</button>
      <button id="pauseBtn">â¸ ä¸€æ™‚åœæ­¢</button>
      <button id="stopBtn">â¹ åœæ­¢</button>
      <span class="pill time" id="timeText">00:00 / 00:00</span>
    </div>

    <div class="section">
      <div class="label">ã‚·ãƒ¼ã‚¯</div>
      <input type="range" id="seek" min="0" max="1000" step="1" value="0" />
      <div class="muted">â€»ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•</div>
    </div>

    <div class="section">
      <div class="label">ã‚­ãƒ¼å¤‰æ›´ï¼ˆé€Ÿåº¦å›ºå®š / ã‚«ãƒ©ã‚ªã‚±ã£ã½ã„ï¼‰</div>
      <input type="range" id="key" min="-12" max="12" step="1" value="0" />
      <p class="big" id="keyValue">0ï¼ˆÂ±0ï¼‰</p>
      <div class="muted">-12 = 1ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸‹ / +12 = 1ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸Š</div>
    </div>

    <div class="section">
      <div class="label">A-Bãƒ«ãƒ¼ãƒ—</div>
      <div class="row">
        <button id="setABtn">Aè¨­å®š</button>
        <button id="setBBtn">Bè¨­å®š</button>
        <button id="clearLoopBtn">è§£é™¤</button>
      </div>
      <p id="loopStatus">æœªè¨­å®š</p>
    </div>

    <div class="section">
      <div class="label">10ç§’æˆ»ã‚‹ / é€²ã‚€</div>
      <div class="row">
        <button id="back10">â—€ 10ç§’</button>
        <button id="fwd10">10ç§’ â–¶</button>
      </div>
    </div>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const loadBtn   = document.getElementById('loadBtn');

    const playBtn  = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn  = document.getElementById('stopBtn');

    const seek     = document.getElementById('seek');
    const timeText = document.getElementById('timeText');

    const key      = document.getElementById('key');
    const keyValue = document.getElementById('keyValue');

    const loopStatus   = document.getElementById('loopStatus');
    const setABtn      = document.getElementById('setABtn');
    const setBBtn      = document.getElementById('setBBtn');
    const clearLoopBtn = document.getElementById('clearLoopBtn');

    const back10 = document.getElementById('back10');
    const fwd10  = document.getElementById('fwd10');

    // ---- audio engine state ----
    let audioCtx = null;
    let buffer = null;

    let soundTouch = null;
    let stSource = null;
    let stFilter = null;
    let stNode = null;

    let isLoaded = false;
    let isPlaying = false;

    let A = null; // seconds
    let B = null; // seconds

    let rafId = null;
    let ignoreSeekInput = false;

    function fmtTime(sec) {
      sec = Math.max(0, sec || 0);
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
    }

    function ensureAudioCtx() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioCtx;
    }

    function destroyEngine() {
      cancelAnimationFrame(rafId);
      rafId = null;

      try { if (stNode) stNode.disconnect(); } catch(e){}
      stNode = null;
      stFilter = null;
      stSource = null;
      soundTouch = null;

      if (audioCtx) {
        // keep context for iOS stability; just suspend
        try { audioCtx.suspend(); } catch(e){}
      }

      isPlaying = false;
      updateButtons();
    }

    function buildEngineFromBuffer() {
      const ctx = ensureAudioCtx();

      // SoundTouch is set with output sample rate
      soundTouch = new window.soundtouch.SoundTouch(ctx.sampleRate);
      soundTouch.tempo = 1.0; // speed fixed

      // pitch ratio by semitone
      const semi = Number(key.value);
      soundTouch.pitch = Math.pow(2, semi / 12);

      stSource = new window.soundtouch.BufferSource(buffer);
      stFilter = new window.soundtouch.SimpleFilter(stSource, soundTouch);

      // WebAudio node (ScriptProcessor internally)
      stNode = window.soundtouch.getWebAudioNode(ctx, stFilter);

      // A-B loop (sample position based)
      // BufferSource.position is in samples (by SoundTouch.js implementation)
      // We clamp inside the audio processing loop by periodically checking in UI loop and forcing position.
    }

    function currentTimeSec() {
      if (!isLoaded || !audioCtx || !stSource) return 0;
      const sr = audioCtx.sampleRate || 44100;
      return (stSource.position || 0) / sr;
    }

    function durationSec() {
      return buffer ? buffer.duration : 0;
    }

    function seekTo(sec) {
      if (!isLoaded || !audioCtx || !stSource) return;
      const d = durationSec();
      sec = Math.max(0, Math.min(d, sec));
      const sr = audioCtx.sampleRate || 44100;
      stSource.position = Math.floor(sec * sr);
    }

    function updateButtons() {
      playBtn.disabled  = !isLoaded || isPlaying;
      pauseBtn.disabled = !isLoaded || !isPlaying;
      stopBtn.disabled  = !isLoaded;
      setABtn.disabled  = !isLoaded;
      setBBtn.disabled  = !isLoaded;
      clearLoopBtn.disabled = !isLoaded;
      back10.disabled   = !isLoaded;
      fwd10.disabled    = !isLoaded;
      seek.disabled     = !isLoaded;
      key.disabled      = !isLoaded;
    }

    function updateTimeUI() {
      if (!isLoaded) {
        timeText.textContent = '00:00 / 00:00';
        return;
      }

      const t = currentTimeSec();
      const d = durationSec();
      timeText.textContent = `${fmtTime(t)} / ${fmtTime(d)}`;

      // Update seek slider without fighting user dragging
      if (!ignoreSeekInput) {
        const v = d > 0 ? Math.round((t / d) * 1000) : 0;
        seek.value = String(v);
      }

      // A-B loop enforcement
      if (A !== null && B !== null && isPlaying) {
        if (t >= B) {
          seekTo(A);
        }
      }

      // stop at end
      if (isPlaying && d > 0 && t >= d) {
        // loop off at end
        isPlaying = false;
        updateButtons();
        try { audioCtx.suspend(); } catch(e){}
      }
    }

    function tick() {
      updateTimeUI();
      rafId = requestAnimationFrame(tick);
    }

    async function loadSelectedFile() {
      const f = fileInput.files && fileInput.files[0];
      if (!f) { alert('éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã‚“ã§ãã ã•ã„'); return; }

      destroyEngine();

      const ctx = ensureAudioCtx();
      // iOS: must resume on user gesture (we are in a click)
      try { await ctx.resume(); } catch(e){}

      const arrayBuf = await f.arrayBuffer();
      buffer = await ctx.decodeAudioData(arrayBuf);

      // reset loop points
      A = null; B = null;
      loopStatus.innerText = 'æœªè¨­å®š';

      buildEngineFromBuffer();
      isLoaded = true;
      isPlaying = false;

      updateButtons();
      updateTimeUI();
      if (!rafId) tick();
    }

    async function play() {
      if (!isLoaded) return;
      const ctx = ensureAudioCtx();
      try { await ctx.resume(); } catch(e){}

      // connect each time to ensure audio starts
      try { stNode.disconnect(); } catch(e){}
      stNode.connect(ctx.destination);

      isPlaying = true;
      updateButtons();
    }

    async function pause() {
      if (!isLoaded) return;
      if (!audioCtx) return;
      try { await audioCtx.suspend(); } catch(e){}
      isPlaying = false;
      updateButtons();
    }

    async function stop() {
      if (!isLoaded) return;
      await pause();
      seekTo(0);
      isPlaying = false;
      updateButtons();
    }

    function applyKeyChange() {
      const semi = Number(key.value);
      keyValue.textContent = `${semi}ï¼ˆÂ±${Math.abs(semi)}ï¼‰`;

      if (!isLoaded || !soundTouch) return;

      // Rebuild pitch processor with same position, keep tempo=1
      const t = currentTimeSec();

      const wasPlaying = isPlaying;
      // stop audio output
      try { if (stNode) stNode.disconnect(); } catch(e){}
      try { if (audioCtx) audioCtx.suspend(); } catch(e){}

      // rebuild engine
      buildEngineFromBuffer();
      seekTo(t);

      // resume if needed
      if (wasPlaying) {
        // connect + resume
        stNode.connect(audioCtx.destination);
        audioCtx.resume().catch(()=>{});
        isPlaying = true;
      } else {
        isPlaying = false;
      }
      updateButtons();
    }

    // ---- UI events ----
    loadBtn.addEventListener('click', loadSelectedFile);

    playBtn.addEventListener('click', play);
    pauseBtn.addEventListener('click', pause);
    stopBtn.addEventListener('click', stop);

    key.addEventListener('input', applyKeyChange);

    seek.addEventListener('pointerdown', () => { ignoreSeekInput = true; });
    seek.addEventListener('pointerup', () => { ignoreSeekInput = false; });
    seek.addEventListener('input', () => {
      if (!isLoaded) return;
      const d = durationSec();
      const ratio = Number(seek.value) / 1000;
      seekTo(d * ratio);
      updateTimeUI();
    });

    setABtn.addEventListener('click', () => {
      if (!isLoaded) return;
      A = currentTimeSec();
      if (B !== null && B <= A) { B = null; }
      loopStatus.innerText = 'A:' + A.toFixed(1) + (B !== null ? (' / B:' + B.toFixed(1)) : '');
    });

    setBBtn.addEventListener('click', () => {
      if (!isLoaded) return;
      if (A === null) { alert('å…ˆã«Aã‚’è¨­å®šã—ã¦ãã ã•ã„'); return; }
      B = currentTimeSec();
      if (B <= A) { alert('Bã¯Aã‚ˆã‚Šå¾Œã«ã—ã¦ãã ã•ã„'); B = null; return; }
      loopStatus.innerText = 'A:' + A.toFixed(1) + ' / B:' + B.toFixed(1);
    });

    clearLoopBtn.addEventListener('click', () => {
      A = null; B = null;
      loopStatus.innerText = 'è§£é™¤';
    });

    function skip(sec) {
      if (!isLoaded) return;
      seekTo(currentTimeSec() + sec);
      updateTimeUI();
    }
    back10.addEventListener('click', () => skip(-10));
    fwd10.addEventListener('click', () => skip(10));

    // init
    keyValue.textContent = '0ï¼ˆÂ±0ï¼‰';
    updateButtons();
    updateTimeUI();
  </script>
</body>
</html>
